$date
	Wed Apr 13 16:46:30 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$scope module TOP $end
$var wire 12 ! ADDR_F [11:0] $end
$var wire 12 " ADDR_G [11:0] $end
$var wire 4 # CHARA [3:0] $end
$var wire 1 $ CLK $end
$var wire 8 % CURRENT_STATE_F [7:0] $end
$var wire 8 & CURRENT_STATE_G [7:0] $end
$var wire 1 ' EN $end
$var wire 1 ( EN_A $end
$var wire 1 ) EN_MATCH $end
$var wire 8 * FAILURE_STATE [7:0] $end
$var wire 1 + MATCH $end
$var wire 8 , NEXT_STATE [7:0] $end
$var wire 8 - NOW_STATE_A [7:0] $end
$var wire 8 . NOW_STATE_OUT [7:0] $end
$var wire 1 / RST $end
$var wire 8 0 STRING [7:0] $end
$scope module GOTO_RAM $end
$var wire 12 1 ADDR_G [11:0] $end
$var wire 1 $ CLK $end
$var wire 1 / RST $end
$var reg 4 2 CHARA [3:0] $end
$var reg 8 3 CURRENT_STATE_G [7:0] $end
$var reg 8 4 NEXT_STATE [7:0] $end
$upscope $end
$scope module GOTO_ADDR $end
$var wire 1 $ CLK $end
$var wire 1 / RST $end
$var reg 12 5 ADDR_G [11:0] $end
$upscope $end
$scope module FAILURE_RAM $end
$var wire 12 6 ADDR_F [11:0] $end
$var wire 1 $ CLK $end
$var wire 1 / RST $end
$var reg 8 7 CURRENT_STATE_F [7:0] $end
$var reg 8 8 FAILURE_STATE [7:0] $end
$upscope $end
$scope module FAILURE_ADDR $end
$var wire 1 $ CLK $end
$var wire 1 / RST $end
$var reg 12 9 ADDR_F [11:0] $end
$upscope $end
$scope module TABLE_READER $end
$var wire 1 : CHARA_EN $end
$var wire 1 $ CLK $end
$var wire 1 ' EN $end
$var wire 1 / RST $end
$var wire 1 ; SEARCH_OUT $end
$var wire 8 < STRING [7:0] $end
$var reg 1 = EN_NEXT $end
$var reg 1 > FLUG $end
$var reg 8 ? NOW_STATE [7:0] $end
$var integer 32 @ i [31:0] $end
$var integer 32 A j [31:0] $end
$var integer 32 B k [31:0] $end
$var integer 32 C l [31:0] $end
$scope function PROCESS_STRING $end
$var reg 1 D CHARA_EN $end
$var reg 1 E EN $end
$var reg 1 F PROCESS_STRING $end
$upscope $end
$upscope $end
$scope module TABLE_READER1 $end
$var wire 1 G CHARA_EN $end
$var wire 1 $ CLK $end
$var wire 1 ( EN $end
$var wire 8 H NOW_STATE_IN [7:0] $end
$var wire 1 / RST $end
$var wire 1 I SEARCH_OUT1 $end
$var wire 8 J STRING [7:0] $end
$var reg 1 K EN_MATCH $end
$var reg 1 L FLUG $end
$var reg 8 M NOW_STATE_OUT [7:0] $end
$var integer 32 N i [31:0] $end
$var integer 32 O j [31:0] $end
$var integer 32 P k [31:0] $end
$var integer 32 Q l [31:0] $end
$scope function PROCESS_STRING1 $end
$var reg 1 R CHARA_EN $end
$var reg 1 S EN $end
$var reg 1 T PROCESS_STRING1 $end
$upscope $end
$upscope $end
$scope module REGISTER $end
$var wire 1 $ CLK $end
$var wire 1 ' EN $end
$var wire 1 ( EN1 $end
$var wire 8 U NOW_STATE [7:0] $end
$var wire 8 V NOW_STATE1 [7:0] $end
$var wire 1 / RST $end
$var reg 8 W STATE [7:0] $end
$upscope $end
$scope module MATCH $end
$var wire 1 $ CLK $end
$var wire 1 ) EN $end
$var wire 1 X MATCH_JUDGE $end
$var wire 1 / RST $end
$var wire 8 Y STATE_DATA [7:0] $end
$var reg 1 Z MATCH $end
$var integer 32 [ a [31:0] $end
$scope function MATCHING $end
$var reg 1 \ EN $end
$var reg 1 ] MATCHING $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
x]
x\
bx [
xZ
bx Y
xX
bx W
bx V
bx U
xT
0S
zR
bx Q
bx P
bx O
bx N
bx M
xL
xK
bx J
xI
bx H
zG
xF
0E
zD
bx C
bx B
bx A
bx @
bx ?
x>
x=
bx <
x;
z:
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
0/
bx .
bx -
bx ,
x+
bx *
x)
0(
0'
bx &
bx %
0$
bx #
bx "
bx !
$end
#5
b0 5
b0 "
b0 1
b0 9
b0 !
b0 6
1$
#10
b1 C
1>
b11 ?
b11 -
b11 H
b11 U
b11 B
1D
b1011 @
b11 A
0E
0$
b1011 0
b1011 <
b1011 J
1'
1/
#15
b11 W
b1 9
b1 !
b1 6
b0 8
b0 *
b1 7
b1 %
b1 5
b1 "
b1 1
b1 4
b1 ,
b1010 2
b1010 #
b0 3
b0 &
1$
#20
1Z
1+
b1010 [
0\
zD
1K
1)
b100 M
b100 .
b100 V
b100 Y
b0 Q
1L
b10 P
1R
b1011 N
b10 O
1S
0$
b1100 0
b1100 <
b1100 J
0'
1(
#25
b10 4
b10 ,
b1011 2
b1011 #
b1 3
b1 &
b10 5
b10 "
b10 1
b11 8
b11 *
b10 7
b10 %
b10 9
b10 !
b10 6
b100 W
1$
#30
0$
b1101 0
b1101 <
b1101 J
#35
b11 9
b11 !
b11 6
b0 8
b0 *
b11 7
b11 %
b11 5
b11 "
b11 1
b11 4
b11 ,
b0 3
b0 &
1$
#40
0$
